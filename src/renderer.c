#include "renderer.h"

#include <SDL3/SDL.h>
#include <stdlib.h>
#include <assert.h>
#include <stdio.h>

#include "lib/stb/stb_image.h"

#define ren_max(a, b) ((a) > (b) ? (a) : (b))
#define ren_min(a, b) ((a) < (b) ? (a) : (b))

extern SDL_Renderer *renderer;
extern SDL_Texture *screen_texture;
extern Image *screen_image;

static Rect clip;
static Font *set_font;

static Rect intersect_rects(Rect a, Rect b) {
    int x1 = ren_max(a.x, b.x);
    int y1 = ren_max(a.y, b.y);
    int x2 = ren_min(a.x + a.width, b.x + b.width);
    int y2 = ren_min(a.y + a.height, b.y + b.height);
    return (Rect) { x1, y1, x2 - x1, y2 - y1 };
}

static inline Color blend_pixel(Color dst, Color src) {
    Color res;
    res.w = (dst.w & 0xff00ff) + ((((src.w & 0xff00ff) - (dst.w & 0xff00ff)) * src.a) >> 8);
    res.g = dst.g + (((src.g - dst.g) * src.a) >> 8);
    res.a = dst.a;
    return res;
}

static inline Color blend_pixel2(Color dst, Color src, Color clr) {
    src.a = (src.a * clr.a) >> 8;
    int ia = 0xff - src.a;
    dst.r = ((src.r * clr.r * src.a) >> 16) + ((dst.r * ia) >> 8);
    dst.g = ((src.g * clr.g * src.a) >> 16) + ((dst.g * ia) >> 8);
    dst.b = ((src.b * clr.b * src.a) >> 16) + ((dst.b * ia) >> 8);
    return dst;
}


static inline Color blend_pixel3(Color dst, Color src, Color clr, Color add) {
    src.r = ren_min(255, src.r + add.r);
    src.g = ren_min(255, src.g + add.g);
    src.b = ren_min(255, src.b + add.b);
    return blend_pixel2(dst, src, clr); // signal indentation bug to rxi
}

static void* read_file(const char *filename, int *len) {
    FILE *fp = fopen(filename, "rb");
    if (!fp) { return NULL; }
    fseek(fp, 0, SEEK_END);
    int n = ftell(fp);
    fseek(fp, 0, SEEK_SET);
    char *buf = malloc(n + 1);
    fread(buf, 1, n, fp);
    fclose(fp);
    if (len) { *len = n; }
    return buf;
}

static bool check_column(Image *img, int x, int y, int h) {
    while (h > 0) {
        if (img->pixels[x + y * img->width].a) {
            return true;
        }
        y++; h--;
    }
    return false;
}

static Font* load_font_from_image(Image *img) {
    if (!img) { return NULL; }
    Font *font = malloc(sizeof(Font));
    font->image = img;

    // init glyphs
    for (int i = 0; i < 256; i++) {
        Glyph *g = &font->glyphs[i];
        Rect r = {
            (img->width / 16) * (i % 16),
            (img->height / 16) * (i / 16),
            img->width / 16,
            img->height / 16
        };
        // right-trim rect
        for (int x = r.x + r.width - 1; x >= r.x; x--) {
            if (check_column(font->image, x, r.y, r.height)) { break; }
            r.width--;
        }
        // left-trim rect
        for (int x = r.x; x < r.x + r.width; x++) {
            if (check_column(font->image, x, r.y, r.height)) { break; }
            r.x++;
            r.width--;
        }
        // set xadvance and rect
        g->xadv = r.width + 1;
        g->rect = r;
    }

    font->glyphs[' '].rect = (Rect) {0};
    font->glyphs[' '].xadv = font->glyphs['a'].xadv;

    return font;
}

static void *font_png_data;
static int   font_png_size;

void ren_init() {
    clip = ren_rect(0, 0, screen_image->width, screen_image->height);

    for (int y = 0; y < screen_image->height; y++) {
        for (int x = 0; x < screen_image->width; x++) {
            screen_image->pixels[x + y * screen_image->width] = ren_rgb(0, 0, 0); // investigate why this is necessary
        }
    }

    set_font = ren_load_font_mem(font_png_data, font_png_size);
}

void ren_update() {
    SDL_UpdateTexture(screen_texture, NULL, screen_image->pixels, screen_image->width * sizeof(uint32_t));
    SDL_RenderClear(renderer);
    SDL_RenderTexture(renderer, screen_texture, NULL, NULL);
    SDL_RenderPresent(renderer);
}

Image* ren_create_image(int width, int height) {
    assert(width > 0 && height > 0);
    Image *image = calloc(1, sizeof(Image) + width * height * sizeof(Color));
    image->pixels = (void*) (image + 1);
    image->width = width;
    image->height = height;
    return image;
}

Image* ren_load_image_file(const char *filename) {
    int len;
    void *data = read_file(filename, &len);
    if (!data) { return NULL; }
    Image *res = ren_load_image_mem(data, len);
    free(data);
    return res;
}

Image* ren_load_image_mem(void *data, int len) {
    int width, height;
    stbi_uc *pixels = stbi_load_from_memory(data, len, &width, &height, NULL, 4);
    if (!pixels) { return NULL; }

    Image *image = ren_create_image(width, height);
    memcpy(image->pixels, pixels, width * height * sizeof(Color));
    stbi_image_free(pixels);

    uint8_t* bytes = (uint8_t*)image->pixels;
    int32_t n = image->width * image->height * sizeof(uint32_t);
    for (int32_t i = 0; i < n; i += 4) {
        uint8_t b = bytes[i];
        bytes[i] = bytes[i + 2];
        bytes[i + 2] = b;
    }

    return image;
}

void ren_destroy_image(Image *image) {
    free(image);
}

Font* ren_load_font_file(const char *filename) {
    return load_font_from_image(ren_load_image_file(filename));
}

Font* ren_load_font_mem(void *data, int len) {
    return load_font_from_image(ren_load_image_mem(data, len));
}

void ren_destroy_font(Font *font) {
    free(font->image);
    free(font);
}

int ren_text_width(Font *font, const char *text) {
    int x = 0;
    for (uint8_t *p = (void*) text; *p; p++) {
        x += font->glyphs[*p].xadv;
    }
    return x;
}

int ren_text_height(Font *font) {
    return font->image->height / 16;
}

int ren_text_width_default(const char *text) {
    int x = 0;
    for (uint8_t *p = (void*) text; *p; p++) {
        x += set_font->glyphs[*p].xadv;
    }
    return x;
}

int ren_text_height_default() {
    return set_font->image->height / 16;
}

void ren_clear(Color color) {
    ren_draw_rect(ren_rect(0, 0, 0xffffff, 0xffffff), color);
}

void ren_set_clip(Rect rect) {
    Rect screen_rect = ren_rect(0, 0, screen_image->width, screen_image->height);
    clip = intersect_rects(rect, screen_rect);
}

void ren_draw_point(int x, int y, Color color) {
    if (color.a == 0) { return; }
    Rect r = clip;
    if (x < r.x || y < r.y || x >= r.x + r.width || y >= r.y + r.height ) {
        return;
    }
    Color *dst = &screen_image->pixels[x + y * screen_image->width];
    *dst = blend_pixel(*dst, color);
}

void ren_draw_rect(Rect rect, Color color) {
    if (color.a == 0) { return; }
    rect = intersect_rects(rect, clip);
    Color *d = &screen_image->pixels[rect.x + rect.y * screen_image->width];
    int dr = screen_image->width - rect.width;
    for (int y = 0; y < rect.height; y++) {
        for (int x = 0; x < rect.width; x++) {
            *d = blend_pixel(*d, color);
            d++;
        }
        d += dr;
    }
}

void ren_draw_image(Image *img, int x, int y) {
    Rect dst = ren_rect(x, y, img->width, img->height);
    Rect src = ren_rect(0, 0, img->width, img->height);
    ren_draw_image3(img, dst, src, ren_rgb(255, 255, 255), ren_rgb(0, 0, 0));
}


void ren_draw_image2(Image *img, int x, int y, Rect src, Color color) {
    Rect dst = ren_rect(x, y, abs(src.width), abs(src.height));
    ren_draw_image3(img, dst, src, color, ren_rgb(0, 0, 0));
}


void ren_draw_image3(Image *img, Rect dst, Rect src, Color mul_color, Color add_color) {
    if (!src.width || !src.height || !dst.width || !dst.height) { // signal bug to rxi
        return;
    }

    /* do scaled render */
    int cx1 = clip.x;
    int cy1 = clip.y;
    int cx2 = cx1 + clip.width;
    int cy2 = cy1 + clip.height;
    int stepx = (src.width << 10) / dst.width;
    int stepy = (src.height << 10) / dst.height;
    int sy = src.y << 10;

    /* vertical clipping */
    int dy = dst.y;
    if (dy < cy1) { sy += (cy1 - dy) * stepy; dy = cy1; }
    int ey = ren_min(cy2, dst.y + dst.height);

    int blend_fn = 1;
    if (mul_color.w != 0xffffffff) { blend_fn = 2; }
    if ((add_color.w & 0xffffff00) != 0xffffff00) { blend_fn = 3; }

    for (; dy < ey; dy++) {
        if (dy >= cy1 && dy < cy2) {
            int sx = src.x << 10;
            Color *srow = &img->pixels[(sy >> 10) * img->width];
            Color *drow = &screen_image->pixels[dy * screen_image->width];

            /* horizontal clipping */
            int dx = dst.x;
            if (dx < cx1) { sx += (cx1 - dx) * stepx; dx = cx1; }
            int ex = ren_min(cx2, dst.x + dst.width);

            for (; dx < ex; dx++) {
                Color *s = &srow[sx >> 10];
                Color *d = &drow[dx];
                switch (blend_fn) {
                case 1: *d = blend_pixel(*d, *s); break;
                case 2: *d = blend_pixel2(*d, *s, mul_color); break;
                case 3: *d = blend_pixel3(*d, *s, mul_color, add_color); break;
                }
                sx += stepx;
            }
        }
        sy += stepy;
    }
}


int ren_draw_text(char *text, int x, int y, Color color) {
    return ren_draw_text2(set_font, text, x, y, color);
}


int ren_draw_text2(Font *font, char *text, int x, int y, Color color) {
    for (uint8_t *p = (void*) text; *p; p++) {
        Glyph g = font->glyphs[*p];
        ren_draw_image2(font->image, x, y, g.rect, color);
        x += g.xadv;
    }
    return x;
}

static char font_png[] = {
0x89, 0x50, 0x4e, 0x47, 0x0d, 0x0a, 0x1a, 0x0a, 0x00, 0x00, 0x00, 0x0d,
0x49, 0x48, 0x44, 0x52, 0x00, 0x00, 0x00, 0xc0, 0x00, 0x00, 0x01, 0x00,
0x01, 0x03, 0x00, 0x00, 0x00, 0xdf, 0x8d, 0xeb, 0x44, 0x00, 0x00, 0x00,
0x06, 0x50, 0x4c, 0x54, 0x45, 0x47, 0x70, 0x4c, 0xff, 0xff, 0xff, 0x9f,
0x94, 0xa2, 0x43, 0x00, 0x00, 0x00, 0x01, 0x74, 0x52, 0x4e, 0x53, 0x00,
0x40, 0xe6, 0xd8, 0x66, 0x00, 0x00, 0x05, 0x4d, 0x49, 0x44, 0x41, 0x54,
0x58, 0xc3, 0xed, 0x98, 0x3f, 0x88, 0x24, 0x45, 0x14, 0xc6, 0xdf, 0x74,
0x37, 0xdd, 0xd5, 0xbb, 0x75, 0xd3, 0x13, 0x4e, 0x70, 0x48, 0x7b, 0x98,
0x08, 0x06, 0x03, 0x06, 0x2e, 0xb8, 0x4a, 0xbb, 0xd1, 0x04, 0x07, 0x5e,
0x62, 0xde, 0x82, 0x5c, 0x28, 0x03, 0x82, 0x0c, 0xc7, 0xa1, 0x4f, 0x5c,
0xb8, 0x0b, 0x56, 0x9c, 0xf0, 0x44, 0x11, 0x03, 0x95, 0xc5, 0x4c, 0x30,
0x50, 0x30, 0xa8, 0x03, 0x83, 0xe3, 0x18, 0xf5, 0xc2, 0x0d, 0xd7, 0xdc,
0x60, 0xc2, 0x09, 0x46, 0xcf, 0xef, 0x55, 0x55, 0x77, 0x4f, 0xcf, 0x1f,
0x6f, 0x11, 0x5d, 0xf7, 0x8e, 0x2b, 0x8a, 0xde, 0x9e, 0xfe, 0xf5, 0xab,
0x7a, 0xaf, 0x5e, 0x7d, 0xd5, 0x55, 0x4b, 0xb4, 0xb5, 0x24, 0x3c, 0xae,
0xab, 0xfb, 0x49, 0x84, 0x7b, 0xdc, 0xb2, 0x6a, 0xaa, 0xfb, 0x49, 0xb8,
0x7f, 0x72, 0xc0, 0xf6, 0xc8, 0xff, 0xc7, 0x32, 0x5e, 0xf6, 0x6a, 0xa9,
0x92, 0x6a, 0xc5, 0xd1, 0xd4, 0x27, 0x06, 0x6c, 0x8d, 0xfc, 0xe2, 0x96,
0x4e, 0x9e, 0xc7, 0xa7, 0xf8, 0x9b, 0xab, 0xfa, 0x11, 0xdc, 0xd5, 0x34,
0xe9, 0xe4, 0xa3, 0x34, 0x1f, 0x2b, 0x2a, 0x22, 0xca, 0x5b, 0x20, 0x99,
0x1d, 0xa7, 0xc5, 0x54, 0x91, 0x89, 0xe9, 0xd8, 0xb7, 0x41, 0x16, 0x04,
0xc5, 0x69, 0x5c, 0xfc, 0x6c, 0xc1, 0x28, 0x58, 0x02, 0x04, 0x40, 0xfc,
0x26, 0x59, 0x0b, 0x07, 0x02, 0x07, 0xb2, 0xd3, 0x11, 0xf1, 0x2f, 0x16,
0xe4, 0x19, 0x13, 0xaa, 0x07, 0x11, 0xef, 0x75, 0x06, 0x53, 0x0b, 0xc8,
0x59, 0x44, 0xae, 0x2b, 0x01, 0xc3, 0x35, 0xa0, 0xe5, 0xe6, 0x38, 0xa8,
0x00, 0xae, 0xa8, 0xaa, 0x02, 0xa3, 0x60, 0x00, 0x59, 0x14, 0xd1, 0x32,
0xb0, 0xc5, 0xc5, 0xe5, 0x22, 0x2f, 0xb6, 0x0d, 0xd0, 0x45, 0x48, 0xde,
0x38, 0xa6, 0x71, 0x66, 0x74, 0x66, 0xf6, 0x32, 0xd3, 0x4c, 0x27, 0xdc,
0x4c, 0xbb, 0x74, 0xd4, 0xe1, 0xcb, 0x9a, 0x4a, 0x32, 0x53, 0x8d, 0xe0,
0xa8, 0x2f, 0x01, 0x1a, 0x9a, 0xc6, 0xa4, 0x43, 0x7a, 0x41, 0x23, 0x60,
0x0f, 0x06, 0x24, 0x2f, 0x59, 0x90, 0xf0, 0xd5, 0x8c, 0xe7, 0x64, 0xc6,
0x16, 0x94, 0x99, 0x19, 0x74, 0x58, 0x40, 0x9f, 0xcc, 0x11, 0x5e, 0xef,
0x30, 0x2c, 0x8c, 0x98, 0x52, 0x3f, 0x24, 0x01, 0x03, 0x32, 0x7f, 0x02,
0x84, 0x34, 0x4d, 0x04, 0x88, 0x85, 0x03, 0x68, 0x51, 0x3b, 0x40, 0x75,
0x1f, 0x16, 0xc0, 0x07, 0xad, 0x2c, 0xe8, 0x30, 0x5e, 0x11, 0xaf, 0x42,
0x1b, 0xc7, 0x22, 0x61, 0xf4, 0x3f, 0x0e, 0xa1, 0x15, 0xb1, 0x95, 0x12,
0xae, 0x07, 0x1c, 0x6d, 0x1b, 0x09, 0x75, 0x31, 0x54, 0x93, 0xf0, 0x1c,
0x35, 0x33, 0x88, 0x66, 0xaa, 0x49, 0xeb, 0xd2, 0x28, 0xfd, 0x01, 0xf2,
0xf1, 0xaa, 0xc6, 0x68, 0x17, 0x78, 0x64, 0xec, 0x55, 0xcb, 0x38, 0x5e,
0xbe, 0x8b, 0x61, 0x7e, 0x4d, 0x00, 0x59, 0x20, 0x57, 0x7d, 0x89, 0x4d,
0x77, 0xff, 0x37, 0x80, 0xcf, 0x8e, 0xda, 0x20, 0x23, 0x93, 0xdd, 0xfc,
0x16, 0xe0, 0xcb, 0x8f, 0xcd, 0x1c, 0x8f, 0x90, 0xa8, 0x4b, 0x66, 0x01,
0xd0, 0x25, 0xb3, 0xfb, 0xfb, 0x27, 0x00, 0x5f, 0x37, 0x16, 0xf6, 0x06,
0x16, 0xe9, 0xf4, 0x23, 0x80, 0x4f, 0x75, 0x1b, 0xa0, 0x0f, 0x75, 0x74,
0x0b, 0xa0, 0x68, 0xbc, 0x72, 0x6f, 0x18, 0xb8, 0xfb, 0x21, 0x00, 0xdc,
0x75, 0x71, 0x18, 0x1b, 0xc7, 0x58, 0x97, 0x73, 0x17, 0xc7, 0xe3, 0x51,
0xba, 0xc4, 0x5d, 0x2b, 0x62, 0x09, 0x22, 0xa1, 0x85, 0x44, 0x37, 0x45,
0x74, 0x18, 0x2e, 0x8e, 0xe9, 0x9a, 0xcc, 0x44, 0x79, 0xc4, 0x83, 0x0a,
0x68, 0x4d, 0x45, 0x4c, 0xb7, 0x2b, 0x40, 0x2b, 0x80, 0x3c, 0xe8, 0x36,
0xa0, 0xaf, 0x29, 0x77, 0x60, 0x2e, 0x63, 0xe5, 0x01, 0x34, 0x38, 0xa8,
0x81, 0x0c, 0x6a, 0x58, 0xf5, 0x11, 0x52, 0xa9, 0xa9, 0xd7, 0x80, 0x4e,
0x03, 0x4c, 0x0b, 0xa4, 0x02, 0xee, 0xe9, 0x7b, 0x0e, 0x28, 0x0f, 0x90,
0x06, 0xf4, 0x21, 0x29, 0x99, 0x01, 0x2c, 0x1c, 0xc8, 0x66, 0x6e, 0xe1,
0x6a, 0x45, 0x2e, 0xf5, 0xc2, 0x16, 0xb6, 0xfe, 0x42, 0xdd, 0x7b, 0x12,
0x2c, 0xf5, 0x75, 0xe5, 0x7e, 0x51, 0x81, 0xd2, 0x45, 0x54, 0x83, 0xdc,
0x66, 0xf0, 0x66, 0xc2, 0xb3, 0x44, 0xa6, 0x7d, 0x1f, 0x53, 0x34, 0xfb,
0x7e, 0x2e, 0x33, 0x51, 0x49, 0x06, 0x91, 0x89, 0xd2, 0x66, 0xac, 0x8f,
0x49, 0x6d, 0x13, 0x03, 0x0d, 0xfa, 0xb9, 0xec, 0x01, 0x64, 0xe0, 0x81,
0x97, 0x45, 0x05, 0xf4, 0x0a, 0xc0, 0xfa, 0xb5, 0xc9, 0x02, 0x7d, 0x14,
0x1b, 0xfa, 0x70, 0x5e, 0x95, 0x89, 0x6b, 0xca, 0x08, 0x68, 0xeb, 0x43,
0x02, 0xb8, 0xb3, 0x69, 0xa5, 0x12, 0x30, 0xda, 0xb8, 0x76, 0xfc, 0x47,
0x4b, 0xd2, 0xda, 0xa3, 0xc0, 0x6d, 0x17, 0x2b, 0x50, 0x2e, 0x2d, 0xaf,
0x1c, 0xfd, 0x3d, 0x98, 0x27, 0xe6, 0x24, 0xa1, 0x59, 0xad, 0x28, 0x0b,
0xde, 0x02, 0xc0, 0x8f, 0xb9, 0xe6, 0xb2, 0x02, 0xca, 0x82, 0x3b, 0x0e,
0x98, 0x2e, 0xd5, 0xa0, 0x87, 0xfd, 0x50, 0x60, 0x9b, 0x12, 0x90, 0x78,
0x80, 0x39, 0x9f, 0xd7, 0x7d, 0x08, 0x08, 0x9b, 0xa6, 0x8a, 0x16, 0x48,
0x05, 0x88, 0x3e, 0x70, 0xbf, 0xec, 0x95, 0x11, 0x7d, 0x98, 0x19, 0xf4,
0x91, 0x78, 0xaf, 0x24, 0x72, 0xd3, 0xd2, 0x87, 0xa9, 0x22, 0xa7, 0x36,
0x50, 0xe6, 0xec, 0x63, 0xf7, 0x74, 0xbf, 0xfb, 0xd8, 0xee, 0x77, 0x9f,
0xe6, 0xe3, 0xc2, 0x9f, 0x3f, 0xe0, 0x92, 0xf3, 0xca, 0x1f, 0x2d, 0x12,
0x3a, 0x21, 0x7a, 0x78, 0x4a, 0x0b, 0x59, 0x93, 0xec, 0x31, 0x63, 0x14,
0x32, 0xe9, 0x01, 0x2b, 0x3e, 0x09, 0x0d, 0xcb, 0x5b, 0xbc, 0xef, 0xc0,
0x71, 0x5c, 0x50, 0x5c, 0xb2, 0x1c, 0x12, 0x72, 0x00, 0x58, 0x1c, 0xb8,
0x85, 0xec, 0x8b, 0x98, 0x0e, 0xb3, 0x19, 0x3e, 0xfc, 0x94, 0x4e, 0xf8,
0x59, 0x98, 0xf0, 0x0f, 0xce, 0x02, 0x00, 0xdf, 0x61, 0xde, 0x25, 0xda,
0xb9, 0xc6, 0x57, 0x0a, 0x58, 0x7c, 0xe5, 0x9b, 0xca, 0x68, 0x81, 0x8f,
0x6b, 0xca, 0xb4, 0xd3, 0xe3, 0xe7, 0xb8, 0xb1, 0x18, 0x61, 0x9f, 0x0a,
0x0b, 0xcd, 0x62, 0xf1, 0x3c, 0x35, 0x16, 0xf8, 0xe4, 0x7f, 0x07, 0x10,
0xb3, 0xf4, 0x61, 0x2d, 0x3c, 0xa0, 0x38, 0xff, 0x03, 0x20, 0xb4, 0x5e,
0xd9, 0x3e, 0x0e, 0x3c, 0xc8, 0xcc, 0x8d, 0xbb, 0xcc, 0xd8, 0x60, 0x23,
0x0e, 0x78, 0x95, 0xf0, 0x7e, 0x2b, 0x1f, 0x4a, 0x7e, 0xd8, 0xc8, 0x57,
0x87, 0xe8, 0x7c, 0xd2, 0x50, 0x2b, 0xa6, 0xf5, 0x1d, 0x20, 0xfe, 0xe6,
0xf8, 0xb6, 0xdd, 0x6e, 0xdb, 0x75, 0x74, 0x12, 0xd1, 0x50, 0x4b, 0x8a,
0xde, 0x23, 0x7e, 0xe3, 0xe0, 0x4a, 0xe9, 0x00, 0x82, 0x9d, 0x28, 0x9a,
0x58, 0x70, 0xdf, 0x5a, 0x4c, 0x6a, 0x80, 0x5d, 0xd0, 0x09, 0x8c, 0xe2,
0xf2, 0xbe, 0xb5, 0x98, 0xa4, 0x55, 0x53, 0x18, 0x92, 0x13, 0x18, 0x59,
0x00, 0x8b, 0x32, 0x62, 0x6f, 0xe1, 0x4b, 0x5c, 0xde, 0xb0, 0x16, 0x38,
0x34, 0xae, 0x82, 0x1d, 0xe7, 0x55, 0x27, 0x17, 0x10, 0xb7, 0x41, 0x63,
0xa1, 0xd7, 0x2d, 0x5c, 0x1f, 0xba, 0x3e, 0xe2, 0x25, 0x0f, 0x76, 0x12,
0x6b, 0x91, 0x52, 0x5b, 0x1f, 0xf6, 0xd8, 0xe1, 0x22, 0xff, 0xf7, 0x8f,
0x1d, 0x45, 0x87, 0x06, 0x71, 0x31, 0x0c, 0xdd, 0x3e, 0x88, 0x07, 0x11,
0xe3, 0xe3, 0x25, 0x43, 0x9e, 0x07, 0x34, 0x4c, 0x79, 0x18, 0x89, 0x1b,
0x79, 0x87, 0x70, 0x83, 0x40, 0x30, 0x62, 0xd4, 0x8b, 0xe8, 0xd0, 0x9e,
0x79, 0x71, 0xe9, 0x05, 0x9b, 0x56, 0xb8, 0xf7, 0x6f, 0xf1, 0x02, 0xa7,
0x90, 0xcc, 0x9e, 0xca, 0x62, 0xbf, 0xad, 0x75, 0xb5, 0x30, 0xf6, 0x4c,
0xb1, 0x0e, 0xe8, 0x6c, 0xc0, 0xb5, 0x8b, 0xfa, 0x50, 0xd3, 0x1c, 0xa7,
0x90, 0x8c, 0xff, 0x71, 0x53, 0x8f, 0xf6, 0xea, 0xd7, 0x95, 0x38, 0x9a,
0x12, 0x6e, 0xfd, 0xc7, 0xc5, 0x36, 0x10, 0x9c, 0x3d, 0x25, 0xb9, 0x4d,
0x89, 0x33, 0xea, 0xd5, 0x3d, 0x8d, 0xc3, 0xbc, 0xe7, 0x52, 0x62, 0xbb,
0xc9, 0x23, 0x1e, 0x3a, 0x7d, 0xa8, 0x68, 0x7d, 0x03, 0x61, 0x27, 0xb5,
0x52, 0xbd, 0xfa, 0x9f, 0x70, 0xcf, 0x1c, 0xd9, 0x98, 0x64, 0xee, 0x1a,
0x52, 0xba, 0xe7, 0x63, 0x24, 0x7a, 0x51, 0x57, 0x20, 0x2e, 0x49, 0x75,
0x2b, 0x10, 0x15, 0x6d, 0xb0, 0x5b, 0x81, 0x80, 0x5f, 0x6a, 0x00, 0x9a,
0x4a, 0x27, 0x1e, 0x74, 0xe8, 0xe5, 0x96, 0x85, 0x7a, 0x50, 0x5b, 0xb4,
0x9b, 0x52, 0xa3, 0x2d, 0x7d, 0xa8, 0x41, 0xed, 0xd5, 0x3b, 0xcb, 0x60,
0xbc, 0x14, 0xc7, 0xe7, 0xf5, 0xf7, 0xa3, 0x6b, 0xce, 0xf3, 0xd3, 0xb0,
0x9e, 0xf0, 0x1c, 0x62, 0xa9, 0x64, 0x20, 0x22, 0xaa, 0x41, 0x0f, 0x62,
0x81, 0xa2, 0x9c, 0x70, 0x02, 0x11, 0x8e, 0x28, 0x0a, 0xc2, 0x51, 0x01,
0x1d, 0x22, 0x7d, 0xb6, 0x29, 0x11, 0x51, 0xad, 0xa8, 0x47, 0xef, 0x19,
0xa0, 0x28, 0x77, 0xe3, 0x67, 0xe2, 0x91, 0x32, 0xbe, 0x4e, 0x0b, 0x37,
0x68, 0x1e, 0xdc, 0x4c, 0x8c, 0xaf, 0x53, 0x6a, 0x81, 0x7a, 0x52, 0xbf,
0xae, 0x69, 0x9b, 0x38, 0xb7, 0xe9, 0xe3, 0x6a, 0xf1, 0x93, 0x96, 0xba,
0xda, 0xc7, 0xaa, 0x57, 0xe7, 0xa4, 0x8f, 0x2d, 0x63, 0xb5, 0x9c, 0x86,
0xea, 0x5f, 0xce, 0x76, 0x7f, 0x15, 0x17, 0x92, 0x06, 0xa4, 0xc4, 0x29,
0x23, 0xa6, 0x6a, 0xc3, 0x92, 0xb2, 0xa4, 0xc1, 0x29, 0x0a, 0x8f, 0xd2,
0x1a, 0xac, 0x69, 0xa9, 0x02, 0x59, 0x35, 0xfb, 0x02, 0x7a, 0xa5, 0xd5,
0x54, 0x3d, 0x56, 0x44, 0xd7, 0x37, 0x83, 0x8c, 0xaf, 0x6f, 0xb3, 0x78,
0x7b, 0x33, 0x08, 0xe8, 0xdd, 0x33, 0xf5, 0x31, 0xd6, 0xa6, 0xd6, 0xc7,
0x8f, 0xb8, 0xc6, 0x74, 0x7e, 0xfb, 0xab, 0xbf, 0x00, 0xec, 0x51, 0xe8,
0xd2, 0x17, 0x57, 0x55, 0xc1, 0x00, 0x00, 0x00, 0x00, 0x49, 0x45, 0x4e,
0x44, 0xae, 0x42, 0x60, 0x82,
};

static void *font_png_data = font_png;
static int   font_png_size = sizeof(font_png);
